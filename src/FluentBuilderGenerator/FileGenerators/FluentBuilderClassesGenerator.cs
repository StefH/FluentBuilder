// This source code is based on https://justsimplycode.com/2020/12/06/auto-generate-builders-using-source-generator-in-net-5
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FluentBuilderGenerator.Extensions;
using FluentBuilderGenerator.SyntaxReceiver;
using FluentBuilderGenerator.Wrappers;
using Microsoft.CodeAnalysis;

namespace FluentBuilderGenerator.FileGenerators
{
    internal class FluentBuilderClassesGenerator : IFilesGenerator
    {
        private readonly IGeneratorExecutionContextWrapper _wrapper;
        private readonly IAutoGenerateBuilderSyntaxReceiver _receiver;
        private readonly bool _supportsNullable;

        public FluentBuilderClassesGenerator(IGeneratorExecutionContextWrapper wrapper, IAutoGenerateBuilderSyntaxReceiver receiver, bool supportsNullable)
        {
            _wrapper = wrapper;
            _receiver = receiver;
            _supportsNullable = supportsNullable;
        }

        public IEnumerable<FileData> GenerateFiles()
        {
            var allClassSymbols = GetClassSymbols();

            foreach (var classSymbol in allClassSymbols)
            {
                yield return new FileData
                {
                    FileName = $"{classSymbol.GetFileName()}_Builder.g.cs",
                    Text = CreateBuilderCode(classSymbol, allClassSymbols)
                };
            }
        }

        private string CreateBuilderCode(INamedTypeSymbol classSymbol, IReadOnlyList<INamedTypeSymbol> allClassSymbols) => $@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by https://github.com/StefH/FluentBuilder.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

{(_supportsNullable ? "#nullable enable" : string.Empty)}
using System;
using FluentBuilder;
using {classSymbol.ContainingNamespace};

namespace FluentBuilder
{{
    public partial class {classSymbol.GenerateClassName(true)} : Builder<{classSymbol.GenerateClassName()}>{classSymbol.GetWhereStatement()}
    {{
{GenerateWithPropertyCode(classSymbol, allClassSymbols)}
{GenerateBuildMethod(classSymbol)}
    }}
}}
{(_supportsNullable ? "#nullable disable" : string.Empty)}";

        private static string GenerateWithPropertyCode(INamedTypeSymbol classSymbol, IReadOnlyList<INamedTypeSymbol> allClassSymbols)
        {
            //var allClassNames = allClassSymbols.Select(c => c.Name).ToList();
            var properties = GetProperties(classSymbol);
            var className = classSymbol.GenerateClassName(true);

            var sb = new StringBuilder();
            foreach (var property in properties)
            {
                sb.AppendLine($"        private bool _{CamelCase(property.Name)}IsSet;");

                sb.AppendLine($"        private Lazy<{property.Type}> _{CamelCase(property.Name)} = new Lazy<{property.Type}>(() => default({property.Type}));");

                sb.AppendLine($"        public {className} With{property.Name}({property.Type} value) => With{property.Name}(() => value);");

                sb.Append(GenerateWithPropertyFuncMethod(classSymbol, property));

                var existingClassSymbol = allClassSymbols.FirstOrDefault(c => c.Name == property.Type.Name);
                if (existingClassSymbol is not null)
                {
                    sb.Append(GenerateWithPropertyActionMethod(classSymbol, property, existingClassSymbol));
                }

                sb.AppendLine($"        public {className} Without{property.Name}()");
                sb.AppendLine("        {");
                sb.AppendLine($"            With{property.Name}(() => default({property.Type}));");
                sb.AppendLine($"            _{CamelCase(property.Name)}IsSet = false;");
                sb.AppendLine("            return this;");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private static StringBuilder GenerateWithPropertyFuncMethod(INamedTypeSymbol classSymbol, IPropertySymbol property)
        {
            var className = classSymbol.GenerateClassName(true);

            var output = new StringBuilder();
            output.AppendLine($"        public {className} With{property.Name}(Func<{property.Type}> func)");
            output.AppendLine("        {");
            output.AppendLine($"            _{CamelCase(property.Name)} = new Lazy<{property.Type}>(func);");
            output.AppendLine($"            _{CamelCase(property.Name)}IsSet = true;");
            output.AppendLine("            return this;");
            output.AppendLine("        }");
            return output;
        }

        private static StringBuilder GenerateWithPropertyActionMethod(INamedTypeSymbol classSymbol, IPropertySymbol property, INamedTypeSymbol existingClassSymbol)
        {
            var className = classSymbol.GenerateClassName(true);
            var propertyName = property.Type is INamedTypeSymbol propertyNamedType ? propertyNamedType.GenerateClassName(true) : property.Type.Name + "Builder";

            var sb = new StringBuilder();
            sb.AppendLine($"        public {className} With{property.Name}(Action<FluentBuilder.{propertyName}> action) => With{property.Name}(() =>");
            sb.AppendLine("        {");
            sb.AppendLine($"            var builder = new FluentBuilder.{propertyName}();");
            sb.AppendLine("            action(builder);");
            sb.AppendLine("            return builder.Build();");
            sb.AppendLine("        });");
            return sb;
        }

        private static IEnumerable<IPropertySymbol> GetProperties(INamedTypeSymbol classSymbol)
        {
            var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
                .Where(x => x.SetMethod is not null)
                .Where(x => x.CanBeReferencedByName)
                .ToList();

            var propertyNames = properties.Select(x => x.Name);

            var baseType = classSymbol.BaseType;

            while (baseType != null)
            {
                properties.AddRange(baseType.GetMembers().OfType<IPropertySymbol>()
                                            .Where(x => x.CanBeReferencedByName)
                                            .Where(x => x.SetMethod is not null)
                                            .Where(x => !propertyNames.Contains(x.Name)));

                baseType = baseType.BaseType;
            }

            return properties;
        }

        private static string GenerateBuildMethod(INamedTypeSymbol classSymbol)
        {
            var properties = GetProperties(classSymbol).ToArray();
            var output = new StringBuilder();
            var className = classSymbol.GenerateClassName();

            output.AppendLine($@"        public override {className} Build(bool useObjectInitializer = true)
        {{
            if (Object?.IsValueCreated != true)
            {{
                Object = new Lazy<{className}>(() =>
                {{
                    if (useObjectInitializer)
                    {{
                        return new {className}
                        {{");
            output.AppendLine(string.Join(",\r\n", properties.Select(property => $@"                            {property.Name} = _{CamelCase(property.Name)}.Value")));
            output.AppendLine($@"                        }};
                    }}

                    var instance = new {className}();");
            output.AppendLine(string.Join("\r\n", properties.Select(property => $@"                    if (_{CamelCase(property.Name)}IsSet) {{ instance.{property.Name} = _{CamelCase(property.Name)}.Value; }}")));
            output.AppendLine($@"                    return instance;
                }});
            }}

            PostBuild(Object.Value);

            return Object.Value;
        }}

        public static {className} Default() => new {className}();");

            return output.ToString();
        }

        private IReadOnlyList<INamedTypeSymbol> GetClassSymbols()
        {
            var classSymbols = new List<INamedTypeSymbol>();
            foreach (var candidateClass in _receiver.CandidateClasses)
            {
                var fullClassName = candidateClass.GetFullName();

                var classSymbol = _wrapper.GetTypeByMetadataName(fullClassName);
                if (classSymbol is not null)
                {
                    classSymbols.Add(classSymbol);
                }
            }

            return classSymbols;
        }

        private static string CamelCase(string value) => $"{value.Substring(0, 1).ToLowerInvariant()}{value.Substring(1)}";
    }
}